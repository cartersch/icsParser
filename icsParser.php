<?php

// //
//  icsParser.php 
//  
//  Created by Carter Schoenfeld on 2012-10-28.
//  
//  While there are many ical parsers out there
//  I couldn't find one that handled a multiline 
//  DESCRIPTION field. So I built this one.
// 
//  Tested with ical file generated by Exchange 
////



Class icsParser {
   
   var $icsFile         = '';
   var $icsStr          = '';
   var $keywordPosition = array();
   var $icsArray        = array();
   var $icsDetails      = array();
   var $brk             = 'END:VTIMEZONE';
   var $startDateFormat = 'Y-m-d g:i A';
   var $endDateFormat   = 'Y-m-d g:i A';
   
   public function __construct($file){
      $this->icsFile = file_get_contents($file);
      $this->stripHeader();
      $this->createArray();
      $this->parseArrayItems();
   }
   
   public function setDateFormat($type, $format){
      if(strtolower($type) === 'start'){
         $this->startDateFormat = $format;
      } else if(strtolower($type) === 'end'){
         $this->endDateFormat = $format;
      }
      
      $this->icsDetails = array();
      $this->parseArrayItems();  
   }
   
   
   public function getAllEvents(){
      return json_encode($this->icsDetails);
   }
   
   public function getUpcomingEvents($num = 10){
      $today        = date('Y-m-d');
      $counter      = 0;
      $events = array();
      
      foreach ($this->icsDetails as $item) {
         if ($counter === $num) { break; }
         
         if (strtotime($today) <= strtotime($item['start'])){
            array_push($events, $item);
            $counter++;
         }
         
      }
      
      return json_encode($events);
   }
   
   public function getEventsByMonth($m = 0, $y = 0){
      $events = array();

      if ($m === 0){ 
         $m = date('m');
         $y = date('Y'); 
      }
      
      foreach ($this->icsDetails as $item){
         $itemDate = explode( '-', $item['start']);
   
         if($m == $itemDate[1] && $y == $itemDate[0]){
            array_push($events, $item);
         }
      }
      
      return json_encode($events);
   }
   
   ////
   // reduces the size of the string by
   // striping the metadata of the file
   ////
   
   private function stripHeader(){
      $brkLen = strlen($this->brk);
      $brkPt  = strpos($this->icsFile, $this->brk) + $brkLen;
      
      $this->icsStr = substr($this->icsFile, $brkPt);
   }
   
   ////
   // Once the headers are stripped, 
   // the remaining information is turned into an array
   ////
   
   private function createArray(){
      $this->icsArray = preg_split("/BEGIN:VEVENT/", $this->icsStr, -1 ,PREG_SPLIT_NO_EMPTY);
   }
   
   ////
   // Each array gets parsed, and each
   // parsed item gets formatted and 
   // added to the $icsDetails array 
   ////
   
   private function parseArrayItems(){
      foreach($this->icsArray as $item){
         $this->keywordPosition = $this->getKeywordPosition($item);
         $parsedItem['description'] = $this->parseItemString($item, 'description', 'summary');
         $parsedItem['summary']     = $this->parseItemString($item, 'summary', 'dtstart');
         $parsedItem['start']       = $this->parseItemString($item, 'dtstart', 'dtend');
         $parsedItem['end']         = $this->parseItemString($item, 'dtend', 'uid');
         
         $parsedItem['start']       = $this->parseDateString($parsedItem['start'], 'start');
         $parsedItem['end']         = $this->parseDateString($parsedItem['end'], 'end');
         
         array_push($this->icsDetails, $parsedItem);
      }
   }
   
   ////
   // Keywords that from the ics file.
   // these also will act as delimiters
   ////
   
   private function getKeywordPosition($item){
      $kp = array();
      
      $kp['DESCRIPTION'] = strpos($item, 'DESCRIPTION');
      $kp['SUMMARY']     = strpos($item, 'SUMMARY');
      $kp['DTSTART']       = strpos($item, 'DTSTART');
      $kp['DTEND']         = strpos($item, 'DTEND');
      $kp['UID']         = strpos($item, 'UID');
      
      return $kp;
      
   }
   
   private function parseItemString($item, $startWord, $endWord){
      $startPos    = $this->keywordPosition[strtoupper($startWord)] + strlen($startWord) + 1;
      $endPos      = $this->keywordPosition[strtoupper($endWord)];
      $str         = $this->getItemString($item, $startPos, $endPos);
      
      if($startWord === 'dtstart' || $startWord === 'dtend'){
         return $str;
      } else {
         return $this->cleanUpString($str);
      }
   }
   
   private function parseDateString($dateString, $type){
      if($type === 'start'){
         $dateFormat = $this->startDateFormat;
      } else if($type === 'end'){
         $dateFormat = $this->endDateFormat;
      } else {
         $dateFormat = 'Y-m-d g:i A';include 'icsParser.php';
         
      }
      
      $startPos   = strpos($dateString, ':');
      $timeString = substr($dateString, ($startPos + 1));
      
      return date($dateFormat, strtotime($timeString)); 
   }
   
   private function getItemString($item, $startPos, $endPos){
      return substr($item, $startPos, ($endPos - $startPos));
   }
   
   
   private function cleanUpString($str){
      $str = str_replace(array("\r\n ", "\n ", "\r "), '', $str);
      $str = str_replace(array("\\n", "\\N"), "\n", $str);
      $str = stripslashes($str);
      $str = htmlentities($str, ENT_QUOTES);
      
      return $str;
   }
}


?>